<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        
        
        <link rel="shortcut icon" href="../img/favicon.ico">
        <title>1BL - Pseudocode - Free60 Wiki archive</title>
        <link href="../css/bootstrap.min.css" rel="stylesheet">
        <link href="../css/font-awesome.min.css" rel="stylesheet">
        <link href="../css/base.css" rel="stylesheet">
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css">

        <script src="../js/jquery-1.10.2.min.js" defer></script>
        <script src="../js/bootstrap.min.js" defer></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
        <script>hljs.initHighlightingOnLoad();</script> 
    </head>

    <body>
        <div class="navbar fixed-top navbar-expand-lg navbar-dark bg-primary">
            <div class="container">
                <a class="navbar-brand" href="..">Free60 Wiki archive</a>
                <!-- Expander button -->
                <button type="button" class="navbar-toggler" data-toggle="collapse" data-target="#navbar-collapse">
                    <span class="navbar-toggler-icon"></span>
                </button>

                <!-- Expanded navigation -->
                <div id="navbar-collapse" class="navbar-collapse collapse">
                        <!-- Main navigation -->
                        <ul class="nav navbar-nav">
                            <li class="navitem">
                                <a href=".." class="nav-link">Home</a>
                            </li>
                            <li class="navitem">
                                <a href="../%21TODO/" class="nav-link">ToDo</a>
                            </li>
                        </ul>

                    <ul class="nav navbar-nav ml-auto">
                        <li class="nav-item">
                            <a href="#" class="nav-link" data-toggle="modal" data-target="#mkdocs_search_modal">
                                <i class="fa fa-search"></i> Search
                            </a>
                        </li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="container">
            <div class="row">
                    <div class="col-md-3"><div class="navbar-light navbar-expand-md bs-sidebar hidden-print affix" role="complementary">
    <div class="navbar-header">
        <button type="button" class="navbar-toggler collapsed" data-toggle="collapse" data-target="#toc-collapse" title="Table of Contents">
            <span class="fa fa-angle-down"></span>
        </button>
    </div>

    
    <div id="toc-collapse" class="navbar-collapse collapse card bg-secondary">
        <ul class="nav flex-column">
            
            <li class="nav-item" data-level="1"><a href="#1bl-pseudocode" class="nav-link">1BL - Pseudocode</a>
              <ul class="nav flex-column">
              </ul>
            </li>
        </ul>
    </div>
</div></div>
                    <div class="col-md-9" role="main">

<h1 id="1bl-pseudocode">1BL - Pseudocode</h1>
<p>Have not reversed all of the hardware error subroutines.</p>
<pre><code class="c">// version 0x583

#define STACK 0x800002000001F700 // r1
#define TOCP 0x8000020000000000 // r2
#define SRAM 0x8000020000010000
#define NAND 0x80000200C8000000
#define PCI 0x80000200D0000000

#define _HW_REG_POST 0x8000020000061010
#define _HW_REG_61008 0x8000020000061008
#define HW_REG_POST (*((volatile QWORD *)_HW_REG_POST))
#define HW_REG_61008 (*((volatile QWORD *)_HW_REG_61008))

#define BITMASK32(n) ((~0ul) &gt;&gt; 32-bits)
#define BITMASK32_L(n) ~((~0ul) &gt;&gt; bits) // left justified bitmask, assumes the hardware makes bits shifted in 0
#define BITMASK64(n) ((~0ull) &gt;&gt; 64-bits)
#define BITMASK64_L(n) ~((~0ull) &gt;&gt; bits) // left justified bitmask, assumes the hardware makes bits shifted in 0
#define ROTL32(data, bits) ((data &lt;&lt; bits) | data &gt;&gt; 32-bits) &amp; ~0ul
#define ROTR32(data, bits) ((data &gt;&gt; bits) | data &lt;&lt; 32-bits) &amp; ~0ul
#define ROTL64(data, bits) ((data &lt;&lt; bits) | data &gt;&gt; 64-bits) &amp; ~0ull
#define ROTR64(data, bits) ((data &gt;&gt; bits) | data &lt;&lt; 64-bits) &amp; ~0ull

BYTE Salt[0xB] = &lt;redacted&gt;;
BYTE BLKey[0x10] = { &lt;redacted&gt; };
XECRYPT_RSAPUB_2048 xRSA;
xRSA = &lt;redacted&gt;

typedef struct _BLHeader
{
    WORD Magic;         // 0 : 2
    WORD Version;       // 2 : 2
    DWORD Flags;        // 4 : 4
    DWORD EntryPoint;   // 8 : 4
    DWORD Size;         // 0xC : 4
    BYTE key[0x10];     // 0x10 : 0x10
    QWORD Pad[4];       // 0x20 : 0x20
    XECRYPT_SIG Sig;    // 0x40 : 0x100
    // Header: 0x140
}BLHeader, *PBLHeader;

// write to the post bus
void POST(QWORD postCode)
{
    HW_REG_POST = (postCode &lt;&lt; 56);
}

// outputs a given byte, then the same byte OR'ed with 0x80
// probably for their internal post sniffer
void POST_DATA(BYTE outPost)
{
    POST(outPost);
    POST(outPost | 0x80);
}

// outputs a given amount of bytes from a given address in high-low format
void POST_ADDRESS(QWORD pqwAddy, DWORD cbAddy)
{
    for(int i = 0;i &lt; cbAddy;i++)
    {
        BYTE bData = *(BYTE*)pqwAddy+i;
        POST(data &gt;&gt; 4); // output high
        POST(data &amp; 0xF); // output low
    }
}

void PanicGen()
{
    while(1)
        continue;
}

void Panic(QWORD postCode)
{
    POST(postCode);
    PanicGen();
}

QWORD ReadHighestByte(QWORD Address)
{
    return ((*(QWORD*)Address) &gt;&gt; 56);
}

DWORD sub_36A8()
{
    DWORD ret = ReadHighestByte(HW_REG_61008);
    if((ret &amp; 0x80) != 0)
        ret = (~ret) &amp; 0xFF;
    return = ret &amp; 0xF8;
}

// rough translation for the cntlzw instruction
DWORD countLeadingZeros(DWORD data)
{
    DWORD count = 0;
    for(int i = 0;i &lt; 31;i++)
    {
        if(data &gt;&gt; 31-i)
            return count;
        count++;
    }
}

/*
Basically this happens when its detected that the
SOC doesn't carry correct values, it goes into a loop
and starts outputting data from a certain SOC register
(0x8000020000061008) - possibly error register?

It doesn't repeat it's output unless the SOC register changes
*/
void HARDWARE_ERROR_PRINT(DWORD dwUnk1)
{
    while(1)
    {
        BYTE bUnk1_p = ROTL32(dwUnk1, 3) &amp; 0x1F;
        POST_DATA(bUnk1_p | 0x60);

        BYTE tmp = 0;
        BYTE bUnk1 = dwUnk1 &amp; FF;

        if(bUnk1 == 0x78)
            tmp = 1;
        else
        {
            if(bUnk1 == 0)
                sub_3878(tmp);
            else if(bUnk1 == 8)
                sub_38B8(tmp);
            else if(bUnk1 == 0x10)
                sub_3AE0(tmp);
            else if(bUnk1 == 0x18)
                sub_3B30(tmp);
            else if(bUnk1 == 0x20)
                sub_3BB0(tmp);
            else if(bUnk1 == 0x28)
                sub_39C8(tmp);
            else if(bUnk1 == 0x30)
                sub_3F88(tmp, PCI + 0x8000);
            else if(bUnk1 == 0x38)
                sub_3C78(tmp);
            else if(bUnk1 == 0x40)
                sub_3D08(tmp);
            else if(bUnk1 == 0x48)
                sub_3DE0(tmp);
            else if(bUnk1 == 0x50)
                POST_ADDRESS(TOCP+2, 2);
            else if(bUnk1 == 0x58)
                sub_3F88(tmp, PCI);
            else if(bUnk1 == 0x60)
                sub_4008(tmp);
            tmp = 0;
        }

        POST_DATA(bUnk1_p | 0x70);

        DWORD r30 = (countLeadingZeros(bUnk1-0x50) &gt;&gt; 27) &amp; 1;
        do
        {
            for(int i = 1;i &lt; 6;i++)
            {
                DWORD dwUnk2 = sub_36A8();
                if(dwUnk1 &amp; 0xFF != dwUnk2 &amp; 0xFF)
                {
                    dwUnk1 = dwUnk2;
                    i = 0;
                }
            }
        } while(((countLeadingZeros((dwUnk1 &amp; 0xFF) - 0x50) &gt;&gt; 27) &amp; 1) == r30);
    }
}

bool CB_VerifyOffset(DWORD offset, DWORD arg2)
{
    if(offset != (offset + 0xF) &amp; 0xFFFFFFF0)
        return false;
    if(offset - 0x80 &gt; 0x7FFFF7F)
        return false;
    if((arg2 + 0xF) &amp; 0xFFFFFFF0 &gt;= offset - 0x8000000)
        return false;
    return true;
}

// Copies by 0x10 byte blocks
// cBlocks: how many 0x10 byte blocks to copy
void CB_Copy(QWORD dest, QWORD src, DWORD cBlocks)
{
    for(int i = 0; i &lt; cBlocks; i++)
    {
        *(QWORD*)dest+(i*0x10) = *(QWORD*)src+(i*0x10);
        *(QWORD*)dest+(i*0x10)+8 = *(QWORD*)src+(i*0x10)+8;
    }
}

void CB_Jump(QWORD address, QWORD arg2)
{
    // grabs data from the CB before nulling the area
    QWORD r27 = *(QWORD*)SRAM+0x20;
    QWORD r28 = *(QWORD*)SRAM+0x28;
    QWORD r29 = *(QWORD*)SRAM+0x30;
    QWORD r30 = *(QWORD*)SRAM+0x38;
    // nulls 0x20-0x140(?)
    QWORD tmp = SRAM+0x20;
    for(int i = 0; i &lt; 0x12; i++)
    {
        *tmp+(i*0x10) = 0ULL;
        *tmp+(i*0x10)+8 = 0ULL;
    }

    // check the size
    tmp = (((*(DWORD*)SRAM+0xC) + 0xF) &amp; 0xFFFFFFF0);
    if(tmp &gt;= 0x10000)
        Panic(0x98);

    // nulls the area after the CB
    QWORD addy = tmp + SRAM;
    for(int i = 0; i &lt; (tmp - 0x10000) &gt;&gt; 4; i++)
    {
        *addy+(i*0x10) = 0ULL;
        *addy+(i*0x10)+8 = 0ULL;
    }

    // sets up tlb page
    // sets registers r0-r26 to 0
    // jump to CB
    goto (address &amp; 0xFFFF) + 0x2000000;
    return;
}

void CB_Load()
{
    POST(0x11);
    FSB1(); // sub_3450

    POST(0x12);
    FSB2(); // sub_34D0

    POST(0x13);
    FSB3(); // sub_35A8

    POST(0x14);
    FSB4(); // sub_3658

    POST(0x15);
    DWORD cbOffset = *(DWORD*)NAND+8; // r25
    if(!CB_VerifyOffset(cbOffset, 0x10))
        Panic(0x94);

    POST(0x16);
    QWORD cbNAddy = NAND+cbOffset; // r26
    CB_Copy(SRAM, cbNAddy, 1);

    POST(0x17);
    PBLHeader cbHeader = (PBLHeader)SRAM;
    if((cbHeader-&gt;Size - 0x264) &gt; 0xBD9C
        || (cbHeader-&gt;Magic &amp; 0xFFF) != 0x342
        || (cbHeader-&gt;EntryPoint &amp; 0x3)
        || (cbHeader-&gt;EntryPoint) &lt; 0x264 // on slim its &lt; 0x3B8
        || (cbHeader-&gt;Size &amp; 0xFFFFFFFC) &gt;= (cbHeader-&gt;EntryPoint &amp; 0x3) // doesn't make sense, check later offset 0x4340 - On slim it makes sense: if(entrypoint &gt;= size &amp; 0xFFFFFFFC) panic
        || !CB_VerifyOffset(cbOffset, cbHeader-&gt;Size))
        Panic(0x95);

    POST(0x18);
    QWORD tmp = ((cbHeader-&gt;Size + 0xF) &amp; 0xFFFFFFF0);
    CB_Copy(SRAM+0x10, cbNAddy+0x10, (tmp - 0x10) &gt;&gt; 4);

    POST(0x19);
    // overwrites the old key with the new one
    XeCryptHmacSha(BLKey, 0x10, &amp;cbHeader-&gt;key, 0x10, 0, 0, 0, 0, &amp;cbHeader-&gt;key, tmp);

    POST(0x1A);
    XECRYPT_RC4_STATE rc4;
    XeCryptRc4Key(&amp;rc4, cbHeader-&gt;key, 0x10); // key = HmacSha(1BLKey, cbKey, 0x10)

    POST(0x1B);
    XeCryptRc4Ecb(&amp;rc4, SRAM+0x20, tmp - 0x20); // Decrypts everything after the header

    POST(0x1C);
    BYTE Hash[0x14] = { 0 };
    XeCryptRotSumSha(SRAM, 0x10, SRAM+0x140, tmp - 0x140, Hash, 0x14); // hashes everything after the sig

    POST(0x1D);
    if(XeCryptBnQwBeSigDifference(&amp;cbHeader-&gt;Sig, Hash, Salt, &amp;xRSA)) // checks sig against hash with public rsa key
        Panic(0x96);

    POST(0x1E);
    CB_Jump(cbHeader-&gt;EntryPoint, tmp+cbOffset); // sets up tbl page and loads some registers before jumping to cb
    return;
}

void BL_1()
{
    // thread check?

    POST(0x10); // entered 1bl

    // null the sram area
    for(int i = 0; i &lt; 0x1000; i++)
    {
        *(QWORD*)SRAM+(i*0x10) = 0ULL;
        *(QWORD*)SRAM+((i*0x10)+8) = 0ULL;
    }

    DWORD tmp = sub_36A8();
    if((tmp &amp; 0xFF) == 0x50)
        HARDWARE_ERROR_PRINT(tmp); // look into later

    // load and execute the CB
    CB_Load();

    // CB_Load shouldn't return...
    PanicGen();

    return;
}
</code></pre></div>
            </div>
        </div>

        <footer class="col-md-12">
            <hr>
            <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a>.</p>
        </footer>
        <script>
            var base_url = "..",
                shortcuts = {"help": 191, "next": 78, "previous": 80, "search": 83};
        </script>
        <script src="../js/base.js" defer></script>
        <script src="../search/main.js" defer></script>

        <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="searchModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="searchModalLabel">Search</h4>
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
            </div>
            <div class="modal-body">
                <p>
                    From here you can search these documents. Enter
                    your search terms below.
                </p>
                <form>
                    <div class="form-group">
                        <input type="text" class="form-control" placeholder="Search..." id="mkdocs-search-query" title="Type search term here">
                    </div>
                </form>
                <div id="mkdocs-search-results"></div>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div><div class="modal" id="mkdocs_keyboard_modal" tabindex="-1" role="dialog" aria-labelledby="keyboardModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="keyboardModalLabel">Keyboard Shortcuts</h4>
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
            </div>
            <div class="modal-body">
              <table class="table">
                <thead>
                  <tr>
                    <th style="width: 20%;">Keys</th>
                    <th>Action</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td class="help shortcut"><kbd>?</kbd></td>
                    <td>Open this help</td>
                  </tr>
                  <tr>
                    <td class="next shortcut"><kbd>n</kbd></td>
                    <td>Next page</td>
                  </tr>
                  <tr>
                    <td class="prev shortcut"><kbd>p</kbd></td>
                    <td>Previous page</td>
                  </tr>
                  <tr>
                    <td class="search shortcut"><kbd>s</kbd></td>
                    <td>Search</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div>

    </body>
</html>
